学习 Redis 的基础知识以及相关实现。

------



# Redis 做分布式锁 

作用： 分布式锁来限制程序的并发执行

## 基本用法

分布式锁的实现思路：一个线程先占位，当别的线程进来操作的时候，发现已经有人占位了，就会放弃或者稍后再尝试。

在 redis 中，占位命令 用setnx 指令，先进来的线程先占位，然后开始执行业务，线程的执行操作完成后，再调用 del 指令释放位置。

1. 如果代码业务执行过程中抛出异常或者是挂了，这样会导致 del 指令没有被调用，原有的锁无法被释放，后来的请求全部被堵塞，锁永远无得不到释放

   解决方式：给锁添加一个过期时间，确保锁在一定时间之后，能够得到释放，使用 expire 指令

2. 获取锁和设置过期时间这两个操作不具备原子性，如果这两个操作之间服务器挂了，也会引发死锁

   解决方式：在 Redis 2.8 开始  setnx 指令 和 expire 指令 可以一起执行了，也就是

```Java
set (String key, String value,SetParams params)
```

3. 添加超时时间后，锁会自动释放，但是如果要执行的业务非常耗时间，超过了过期时间的话，可能会引发紊乱。比如说：第一个线程首先获取到锁，然后开始执行业务，结果 超时了，第一个线程的任务还没执行完，锁就被释放了，此时第二个线程会获取到锁开始执行，在第二个线程执行一会后，第一个线程执行完了，此时第一个线程会释放锁，但是，第一个线程释放的是第二个线程的锁，释放之后，第三个线程进入了。

   解决方式 : 将锁的 value 设置为 一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，如果一致，再去释放，否则就不释放。

   这个方法需要去查看锁的 value, 比较value  的值，释放锁。这是 3 个步骤，不具有原子性 。

   ​	解决方式是引入 lua 脚本 ，它可以在 Redis 服务器 原子的执行多个 Redis 命令

   ​	可以提前在 Redis 服务端写好 脚本，然后在 Java 客户端调用。
