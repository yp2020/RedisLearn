学习 Redis 的基础知识以及相关实现。

------



## Redis 做分布式锁 

作用： 分布式锁来限制程序的并发执行

分布式锁的实现思路：一个线程先占位，当别的线程进来操作的时候，发现已经有人占位了，就会放弃或者稍后再尝试。

在 redis 中，占位命令 用setnx 指令，先进来的线程先占位，然后开始执行业务，线程的执行操作完成后，再调用 del 指令释放位置。

1. 如果代码业务执行过程中抛出异常或者是挂了，这样会导致 del 指令没有被调用，原有的锁无法被释放，后来的请求全部被堵塞，锁永远无得不到释放

   解决方式：给锁添加一个过期时间，确保锁在一定时间之后，能够得到释放，使用 expire 指令

2. 获取锁和设置过期时间这两个操作不具备原子性，如果这两个操作之间服务器挂了，也会引发死锁

   解决方式：在 Redis 2.8 开始  setnx 指令 和 expire 指令 可以一起执行了，也就是

```Java
set (String key, String value,SetParams params)
```

3. 添加超时时间后，锁会自动释放，但是如果要执行的业务非常耗时间，超过了过期时间的话，可能会引发紊乱。比如说：第一个线程首先获取到锁，然后开始执行业务，结果 超时了，第一个线程的任务还没执行完，锁就被释放了，此时第二个线程会获取到锁开始执行，在第二个线程执行一会后，第一个线程执行完了，此时第一个线程会释放锁，但是，第一个线程释放的是第二个线程的锁，释放之后，第三个线程进入了。

   解决方式 : 将锁的 value 设置为 一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，如果一致，再去释放，否则就不释放。

   这个方法需要去查看锁的 value, 比较value  的值，释放锁。这是 3 个步骤，不具有原子性 。

   ​	解决方式是引入 lua 脚本 ，它可以在 Redis 服务器 原子的执行多个 Redis 命令

   ​	可以提前在 Redis 服务端写好 脚本，然后在 Java 客户端调用。

   

## Redis 做消息队列 

Redis 做消息队列  就是用 list 数据结构来实现，

使用 lpush, rpush,操作来实现入队，lpop, rpop 来实现出队。 

在客户端，维护一个死循环来从队列中读取消息，并处理，

如果队列中有消息，就读取，没有消息，就会陷入死循环，知道下一次有消息进入，

这种死循环会造成大量的资源浪费，可以使用 lbpop,也就是阻塞式弹出

## Redis 做延迟消息队列 

用 Zset,其中 Zset 的score 就是时间。 将 value 存到 redis 中，然后通过 轮询的方式，去不断的读取消息出来。
